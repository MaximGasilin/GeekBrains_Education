-- -------------------------------------------------------------------
-- 1.1 В базе данных shop и sample присутствуют одни и те же таблицы, учебной базы данных. Переместите запись id = 1 из таблицы shop.users в таблицу sample.users. Используйте транзакции.
-- -------------------------------------------------------------------

-- Проверка текущих записей в таблицах.

mysql> SELECT * FROM sample.users;
Empty set (0.00 sec)

SELECT * FROM shop.users; 
+----+--------------------+-------------+---------------------+---------------------+
| id | name               | birthday_at | created_at          | updated_at          |
+----+--------------------+-------------+---------------------+---------------------+
|  1 | Геннадий           | 1990-10-05  | 2020-08-12 16:36:17 | 2020-08-12 16:36:17 |
|  2 | Наталья            | 1984-11-12  | 2020-08-12 16:36:17 | 2020-08-12 16:36:17 |
|  3 | Александр          | 1985-05-20  | 2020-08-12 16:36:17 | 2020-08-12 16:36:17 |
|  4 | Сергей             | 1988-02-14  | 2020-08-12 16:36:17 | 2020-08-12 16:36:17 |
|  5 | Иван               | 1998-01-12  | 2020-08-12 16:36:17 | 2020-08-12 16:36:17 |
|  6 | Мария              | 1992-08-29  | 2020-08-12 16:36:17 | 2020-08-12 16:36:17 |
+----+--------------------+-------------+---------------------+---------------------+
6 rows in set (0.00 sec)

-- Собственно код решения задачи

START TRANSACTION;
Query OK, 0 row(s) affected	(0.000 sec)

INSERT INTO sample.users
	SELECT * FROM shop.users WHERE id = 1;
Query OK, 1 row(s) affected (0.000 sec)
 
DELETE FROM shop.users WHERE id = 1; 
Query OK, 1 row(s) affected (0.000 sec)
 
COMMIT;  
Query OK, 0 row(s) affected	(0.000 sec)

SELECT * FROM sample.users;
+----+------------------+-------------+---------------------+---------------------+
| id | name             | birthday_at | created_at          | updated_at          |
+----+------------------+-------------+---------------------+---------------------+
|  1 | Геннадий         | 1990-10-05  | 2020-08-12 16:36:17 | 2020-08-12 16:36:17 |
+----+------------------+-------------+---------------------+---------------------+
1 row in set (0.00 sec)
   

SELECT * FROM shop.users; 
+----+--------------------+-------------+---------------------+---------------------+
| id | name               | birthday_at | created_at          | updated_at          |
+----+--------------------+-------------+---------------------+---------------------+
|  2 | Наталья            | 1984-11-12  | 2020-08-12 16:36:17 | 2020-08-12 16:36:17 |
|  3 | Александр          | 1985-05-20  | 2020-08-12 16:36:17 | 2020-08-12 16:36:17 |
|  4 | Сергей             | 1988-02-14  | 2020-08-12 16:36:17 | 2020-08-12 16:36:17 |
|  5 | Иван               | 1998-01-12  | 2020-08-12 16:36:17 | 2020-08-12 16:36:17 |
|  6 | Мария              | 1992-08-29  | 2020-08-12 16:36:17 | 2020-08-12 16:36:17 |
+----+--------------------+-------------+---------------------+---------------------+
5 rows in set (0.00 sec)

-- в течение операция я попробовал подключиться из-под другого аккаунта. И действительно, до COMMIT таблицы были в неизмененном состоянии.

-- -------------------------------------------------------------------
-- 1.2 Создайте представление, которое выводит название name товарной позиции из таблицы products и соответствующее название каталога name из таблицы catalogs.
-- -------------------------------------------------------------------

CREATE OR REPLACE VIEW Lesson_9_Task_1_2 AS
SELECT p.name AS product_name
	,c.name AS catalog_name 
FROM shop.products AS p
	LEFT JOIN shop.catalogs AS c
		ON p.catalog_id = c.id;
        
SELECT * FROM Lesson_9_Task_1_2;
+-------------------------+-----------------------------------+
| product_name            | catalog_name                      |
+-------------------------+-----------------------------------+
| Intel Core i3-8100      | Процессоры                        |
| Intel Core i5-7400      | Процессоры                        |
| AMD FX-8320E            | Процессоры                        |
| AMD FX-8320             | Процессоры                        |
| ASUS ROG MAXIMUS X HERO | Материнские платы                 |
| Gigabyte H310M S2H      | Материнские платы                 |
| MSI B250M GAMING PRO    | Материнские платы                 |
+-------------------------+-----------------------------------+
7 rows in set (0.00 sec)

-- -------------------------------------------------------------------
-- 1.3 Пусть имеется таблица с календарным полем created_at. 
-- 	   В ней размещены разряженые календарные записи за август 2018 года '2018-08-01', '2016-08-04', '2018-08-16' и 2018-08-17. 
--     Составьте запрос, который выводит полный список дат за август, выставляя в соседнем поле значение 1, если дата присутствует в исходном таблице и 0, если она отсутствует.
-- -------------------------------------------------------------------

-- создание требуемой таблицы
DROP TABLE IF EXISTS lesson_9_task_1_3;
CREATE TABLE lesson_9_task_1_3 (
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
) ;

INSERT INTO lesson_9_task_1_3 (created_at) VALUES
  ('2018-08-01'),
  ('2016-08-04'),
  ('2018-08-01'),
  ('2018-08-16'),
  ('2018-08-17'),
  ('2018-08-17'),
  ('2018-08-31'),  
  ('2018-08-28'),  
  ('2018-08-25'),  
  ('2018-08-22');
  
SELECT * FROM lesson_9_task_1_3;
+---------------------+
| created_at          |
+---------------------+
| 2018-08-01 00:00:00 |
| 2016-08-04 00:00:00 |
| 2018-08-01 00:00:00 |
| 2018-08-16 00:00:00 |
| 2018-08-17 00:00:00 |
| 2018-08-17 00:00:00 |
| 2018-08-31 00:00:00 |
| 2018-08-28 00:00:00 |
| 2018-08-25 00:00:00 |
| 2018-08-22 00:00:00 |
+---------------------+
10 rows in set (0.00 sec)

-- решение задачи

-- хитрым способом создаю временную табилцу с 36 = 6х6 строками и ограничиваю 31. При этом один из столбцов заполняется всеми днями августа 2018 года.
SET @start := '2018-07-31';
Query OK, 0 rows affected (0.00 sec)

DROP TABLE IF EXISTS calendar;
Query OK, 0 rows affected (0.01 sec)

CREATE TEMPORARY TABLE calendar
SELECT @start := @start + interval 1 day AS calendar_date
	,1 AS tmp_val
FROM (
        SELECT 1 AS Number1 
        UNION ALL SELECT 2
        UNION ALL SELECT 3
        UNION ALL SELECT 4
        UNION ALL SELECT 5
        UNION ALL SELECT 6) AS Numbers1
        CROSS JOIN
        (SELECT 1 AS Number2 
        UNION ALL SELECT 2
        UNION ALL SELECT 3
        UNION ALL SELECT 4
        UNION ALL SELECT 5
        UNION ALL SELECT 6)  AS Numbers2 
LIMIT 31;
Query OK, 31 rows affected, 1 warning (0.00 sec)
Records: 31  Duplicates: 0  Warnings: 1

SELECT c.calendar_date AS date
	,CASE 
		WHEN l.created_at IS NULL THEN 0
	ELSE 1
    END AS result 
FROM calendar AS c
	LEFT JOIN lesson_9_task_1_3 AS l
		ON c.calendar_date = l.created_at
GROUP BY date, result;

+------------+--------+
| date       | result |
+------------+--------+
| 2018-08-01 |      1 |
| 2018-08-02 |      0 |
| 2018-08-03 |      0 |
| 2018-08-04 |      0 |
| 2018-08-05 |      0 |
| 2018-08-06 |      0 |
| 2018-08-07 |      0 |
| 2018-08-08 |      0 |
| 2018-08-09 |      0 |
| 2018-08-10 |      0 |
| 2018-08-11 |      0 |
| 2018-08-12 |      0 |
| 2018-08-13 |      0 |
| 2018-08-14 |      0 |
| 2018-08-15 |      0 |
| 2018-08-16 |      1 |
| 2018-08-17 |      1 |
| 2018-08-18 |      0 |
| 2018-08-19 |      0 |
| 2018-08-20 |      0 |
| 2018-08-21 |      0 |
| 2018-08-22 |      1 |
| 2018-08-23 |      0 |
| 2018-08-24 |      0 |
| 2018-08-25 |      1 |
| 2018-08-26 |      0 |
| 2018-08-27 |      0 |
| 2018-08-28 |      1 |
| 2018-08-29 |      0 |
| 2018-08-30 |      0 |
| 2018-08-31 |      1 |
+------------+--------+
31 rows in set (0.00 sec)

-- При создании таблицы lesson_9_task_1_3 я ошибся в 4-м числе августа. Создал его 2016 годом. Увидел это только в результирующей таблицы. Это был одним из тестов на корректность.

-- удаление временной таблицы после использования

DROP TABLE IF EXISTS calendar;
Query OK, 0 rows affected (0.00 sec)

-- -------------------------------------------------------------------
-- 1.4 Пусть имеется любая таблица с календарным полем created_at. 
--     Создайте запрос, который удаляет устаревшие записи из таблицы, оставляя только 5 самых свежих записей.
-- -------------------------------------------------------------------

--  воспользуюсь ранее созданной таблицей lesson_9_task_1_3. В данный момент она выглядит так:
SET @start := 0;

SELECT @start := @start + 1 AS order_n
	,created_at FROM lesson_9_task_1_3
ORDER BY  created_at DESC;

+---------+---------------------+
| order_n | created_at          |
+---------+---------------------+
|       1 | 2018-08-31 00:00:00 |
|       2 | 2018-08-28 00:00:00 |
|       3 | 2018-08-25 00:00:00 |
|       4 | 2018-08-22 00:00:00 |
|       5 | 2018-08-17 00:00:00 |
|       6 | 2018-08-17 00:00:00 |
|       7 | 2018-08-16 00:00:00 |
|       8 | 2018-08-04 00:00:00 |
|       9 | 2018-08-01 00:00:00 |
|      10 | 2018-08-01 00:00:00 |
+---------+---------------------+
10 rows in set, 1 warning (0.00 sec)

-- удаление всех, кроме 5-ти самых свежих строками

PREPARE stmt FROM "DELETE FROM lesson_9_task_1_3 ORDER BY created_at LIMIT ?";
SET @cnt=(SELECT COUNT(1)-5 FROM lesson_9_task_1_3);
EXECUTE stmt USING @cnt;

-- проверка ерзультата
SET @start := 0;

SELECT @start := @start + 1 AS order_n
	,created_at FROM lesson_9_task_1_3
ORDER BY  created_at DESC;

+---------+---------------------+
| order_n | created_at          |
+---------+---------------------+
|       1 | 2018-08-31 00:00:00 |
|       2 | 2018-08-28 00:00:00 |
|       3 | 2018-08-25 00:00:00 |
|       4 | 2018-08-22 00:00:00 |
|       5 | 2018-08-17 00:00:00 |
+---------+---------------------+
5 rows in set, 1 warning (0.00 sec)
