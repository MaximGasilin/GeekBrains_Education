# Задание #2
#
# Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо
# создать класс Клетка. В его конструкторе инициализировать параметр,
# соответствующий количеству ячеек клетки (целое число). В классе должны быть реализованы методы
# перегрузки арифметических операторов: сложение ( __add__() ), вычитание ( __sub__()) ,
# умножение ( __mul__()) , деление ( __truediv__()).
# Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение и
# целочисленное (с округлением до целого) деление клеток, соответственно.

# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться
# сумме ячеек исходных двух клеток.

# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность
# количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.

# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как
# произведение количества ячеек этих двух клеток.

# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как
# целочисленное деление количества ячеек этих двух клеток.

# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и
# количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида * ****\n*****\n*****. .., где количество ячеек между \ n
# равно переданному аргументу. Если ячеек на формирование ряда не хватает, то в последний
# ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод
# make_order() вернет строку: *****\n*****\n** .
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод
# make_order() вернет строку: *****\n*****\n***** .


class Cage:

    def __init__(self, cells):
        self.cells = cells

    # def __str__(self):
    #     return ''.join(map(lambda elem: ''.join(map(lambda x: f'{str(x):>{max_l + 2}}', elem)) + '\n', self.matrix))

    def __add__(self, other):
        if not isinstance(other, Cage):
            raise ValueError('Клетки нужно складывать только с другими клетками!')
        return Cage(self.cells + other.cells)

    def __sub__(self, other):
        if not isinstance(other, Cage):
            raise ValueError('Из клеток можно вычитать только другие клетки!')
        elif self.cells < other.cells:
            raise ValueError('Уменьшаемая клетка должна быть больше вычитаемой!')
        return Cage(self.cells - other.cells)

    def __mul__(self, other):
        if not isinstance(other, Cage):
            raise ValueError('Клетки можно умножать только на другие клетки!')
        return Cage(self.cells * other.cells)

    def __truediv__(self, other):
        if not isinstance(other, Cage):
            raise ValueError('Клетки можно делить только на другие клетки!')
        elif other.cells == 0:
            raise ValueError('У делителя cells не может быть равным нулю!')
        return Cage(self.cells // other.cells)

    def make_order(self, columns):
        result_str = ('*' * columns + '\n') * (self.cells // columns) + '*' * (self.cells % columns)
        print(result_str)


if __name__ == '__main__':

    par_1 = Cage(12)
    par_1.make_order(5)
    print()

    par_2 = Cage(6)
    par_2.make_order(5)
    print()

    par_3 = par_1 / par_2
    par_3.make_order(5)
    print()

    par_4 = par_1 - par_2
    par_4.make_order(5)
    print()

    par_5 = par_3 * par_1
    par_5.make_order(5)
    print()

    par_6 = par_5 + par_1
    par_6.make_order(5)
    print()